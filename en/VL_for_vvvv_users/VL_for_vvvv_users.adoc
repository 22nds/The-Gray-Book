= VL for vvvv users

At first glance VL looks very similar to vvvv: There are gray nodes, links and IOBoxes and you can basically work with those a usual. But of course it wouldn't make much sense to create a new visual programming language if it was just a copy of vvvv. So we tried to keep the good stuff and added a bunch of new features. In this chapter we try to list concepts that look and sound familiar to vvvv but are in fact different in VL.

WARNING: Images missing!




=== Operations
In vvvv each patch defines exactly one operation. In VL a patch can define any number of operations. Each operation has a user-specified name and version and inherits the category of its patch.

=== IOBoxes vs Pins
In vvvv an IOBox can be used to set or display values. By giving an IOBox a descriptive name you turn it into an input- or output-pin of its patch. In VL we distinguish between IOBoxes and Pins. While IOBoxes can still be used to set or display values you now use explicit Pin elements to specify Inlets and Outlets for operations.

Just like in vvvv create an IOBox by pressing the middle mousebutton while making a connection. If instead you doubleclick while making a connection you create an Inlet or Outlet. 

Both Pins and IOBoxes can be configured via a middleclick on them. Input Pins can also be given a default value.

Another note on pins is that in vvvv you're used to when removing a link that goes into an input pin of a primitive type (value, string, color, enum) that the input pin will store the last values that came in via the link. This is not happening in VL, where input pins cannot store values.

=== Nodes
In vvvv all nodes look the same. In VL we distinguish between Operation and Process nodes: 

* Process nodes hold state (FlipFlop, LFO, ...)
* Operation nodes do not hold state (Length, Separate, ...)

== Evaluation

== Language
=== Values
In vvvv there is only one numerical type. It is called simply "Value" and it is internally represented by a Float64. Any output of type Value can be connected to any input of type value even though they may have different subtypes, like Integer, Boolean, or Bang. 

In VL there are many different types for values:

* Boolean
* Byte
* Integer32
* Integer64
* Float32
* Float64

and for now you can only connect from lower to higher precision, eg. from Integer32 to Float32 (or Float64) but not the other way round.

=== Spreads
In vvvv there are spread generators (like LinearSpread,...) spread operators (like GetSlice, Zip,...) and spread sinks (like Bounds, Mean, ...). The same and more are available in VL with the additional advantage that in VL all spread operations are always available for all datatypes without adding more nodes to the NodeBrowser. See Generics.

In vvvv every connection between two pins is a spread. A spread can have 0, 1 or more slices but still it would be a spread in all cases.  

In VL this is more defined: You need to understand three things:

* There is a difference between a single value and a spread with a single value. 
* When we talk of a spread of Integer32, strings or colors, we write: Spread<Integer32>, Spread<String>, Spread<RGBA>
* A Spread is only one type of collection. Another common type of collection would be a Dictionary or a HashSet, but we can imagine many different types of collections. Anyway for a start you'll mostly use Spreads.

=== Spreading
In vvvv every node can automatically be spreaded, meaning the node is executed for every slice on its inputs. This convenience feature is not (yet) available in VL. We're still thinking about implementing something similar though.

=== Bin Size
Bin Sizes are vvvv's workaround to no having multi-dimensional spreads. As with a Bin Size pin associated with a spreaded pin you can specify how the spreads individual bins are to be interpreted by a node. Since in VL spreads can now contain other spreads the concept of Bin Sizes is no longer necessary.

=== Vectors
In vvvv there is no difference between a 2/3/4-dimensional vector and a spread with 2/3/4 slices. In VL we have explicit types for vectors, ie: Vector2, Vector3 and Vector4. 

=== Framedelay
In vvvv there were two reasons to use framedelays

* to make sure one thing happens after the other
* to store a value for the next frame

In VL you'll only use a FrameDelay node for the first use-case. If your patch needs to store a value for the next frame you're creating a datatype in which case you can now use proper Fields and Pads to access those Fields. See link:reference/vl/fields.adoc[About Fields].

=== Naming Conventions
Name (Version1 Version2) [Category.Subcategory]



=== No more hidden values in pins
In vvvv you can change the value on a pin directly. This can be confusing, because when looking at a node you don't see which pin has a value other than its default. In VL you can only change a pins value by connecting an IOBox. 

=== Adding pins to nodes
Nodes like +, *, Cons,  that have a dynamic pin-count can have pins added/removed by selecting them and pressing CTRL + or CTRL -

== Individual Nodes




