= Importing Nodes
So while it is indeed quite convenient to have access to just about any .net library directly in VL, referencing into dlls is more a feature for advanced users. To make those libraries also accessible to more casual users we want to import them. 

With importing we mean designing the API for the end user:

* Choosing a proper VL Category for your nodes and types. Think from a user standpoint, not from an implementors standpoint when choosing the Category. Align it to the Categories that already exist.
* Choosing which types are needed for the VL user and how they should be named.
* Adjusting VL relevant meta information on the types (like mutability, default value, known type structure).
* Choosing which nodes should be handed to the VL user, categorization, naming, default values of pins, data conversion to align with established VL libraries.
* Designing lifetime management of disposables. See resource providers.
* Adding convenience high level nodes and conversions.
* Putting some thought into where additional records could help out to make the library easier to use.

=== Forwarding a type

==== Adjusting mutability
Dlls don't come with meta information of whether a type is mutable or not. Because of this we need to tell VL.

*Image: Show mutable button*

As already stated most .net types are mutable. So here is how to detect a .net type that is immutable:

* it only has readonly fields
* each field is of a immutable type again
* optional: have `WithFoo(TFoo newValue)` methods to get a new instance (= a new immutable snapshot) of that type, where all fields are set to the values as in this instance, but only the field Foo is set to the newValue 

Now you know how to detect a foreign immutable type, but also how to write such a type in C#.
In an upcoming version of C# watch out for records. They should ease the pain for writing them.
