= Library Design Guidelines

During the design of a library a lot of choices have to be made. Be it regarding namings or patterns being used or datatypes that are being exposed. Here is a collection of guidelines that we followed when we created the VL.CoreLib and other libraries we ship with VL. 

= Namings
== Categories

* Prefer existing Categories over inventing your own
* Avoid extensive use of Subcategories 

== Node Names
* use CamelCasing, no spaces
* for process nodes use nouns: Sequencer, FlipFlop, Copier
* for operation nodes prefer verbs

* avoid node names starting in "As.." like "AsString", use "To.." or "From.." instead

=== Node Versions
* use optional versions in round brackets only to denote more specific versions of an already existing node with the same name. i.e. the simpler one of two nodes with the same name should always have no version while the more specific one has a version that describes its speciality
* Versions are used as an alternative to overloads.
VL does not support function overloading but uses “Versions” instead. So when creating/importing multiple overloads of a function:
** first try to provide meaningful unique names
** if not possible, try to provide meaningful unique version names
** if still not possible, use numbered versions starting with (1). These numbered versions will be hidden in the nodebrowser - differentiation will then be possible via the signature of inputs and outputs

=== Node Tags
Use any words not yet used in the nodes name, version or category that will help people find the node in the node browser

=== Join/Split as Versions
For data-types it often makes sense to have a pair of join/split nodes that let you set/get the individual properties that make it. e.g:

* Vector2 (Join) takes X and Y as inputs
* Vector2 (Split) returns X and Y via its outputs
* RGBA (Join) takes Red, Green, Blue, Alpha as inputs
* RGBA (Split) returns Red, Green, Blue, Alpha via its outputs

[NOTE]
Such join/split nodes must not do anything with the data except setting it to respectively getting it from the internal fields of the datatype.

=== Constructors (Create)


=== Converters (From.../To...)
When to name nodes "From.." or "To..".

If a converter merely converts between units, like from cycles to radians but the data-type of the input and output pins is the same the node name has to mention both units, like: CyclesToRadians. Since the data-type does not change here even hovering the pins wouldn't give sufficient information to understand what the node is doing.

== Pins
* use spaces to separate words all starting with upper case
* avoid using generic names like "Do", "Update", ...

=== Inputs
"Apply" is a reserved word for pin-names and therefore the compilier will complain when a user chooses this name manually for a pin. The reason for this is that there is  a pattern where an "Apply" pin will automatically be created for operations. Like this, whenever we encounter an "Apply" pin we can be sure that this pattern is applied.

==== Operations
Any operation (both utility or member) that has 

* no output 
* or exactly one output whose type is the same as the 
type of its first input

automatically gets an "Apply" input. The "Apply" pin is hidden by default and can be shown via the -> Configure menu on the node. It is set to "true" by default. Setting it to "false" will bypass the operation and simply pass the input value through to the output

==== Process Nodes
Any operation of a process node that has

* no output

automatically gets an input that is named after the operation. This pin is set to "false" by default meaning the operation is not executed. Setting the pin to "true" will execute the operation.

Also see Pin Groups below.

=== Outputs
* Output vs. Result
* see below: Nodes that work async

= Standard Datatypes
In order to keep the number of datatypes a user typically has to deal with at a managable level here is a list of datatypes that we use on inputs and outputs of nodes:

* Boolean
* Byte
* Integer32/64
* Float32/64
* Vector2/3/4
* Matrix
* Char
* String
* Path
* Spread<T>

Note that in the implementation of a node you can of course use any datatype you want. 

= Standard Units
* Color Components (red, green, blue, alpha, hue, saturation, lightness) range from 0 to 1
* Angles are specified in cycles (a range from 0 to 1 counter clock-wise)

= Patterns
== Pin Groups
the rules to get free pingroups

== Adaptive Nodes
how to create an adaptive

* definition
* implementation

== Process Nodes
=== Reset Inputs
Reset always takes precedence over other inputs (is lowest in process explorer)
∘ eg: FlipFlop

== Nodes that operate async
* typical outputs
** In Progress
** On Completed
** Success
** Error

== Exception Handling
Still to be defined (see internal issue #1511):

* simply throw errors as they occur
* test input ranges to prevent errors (e.g clamp or wrap incoming values to a save range,...). optionally report overflow via an Overflow (Bool) output
* return Default if operation fails and report Success
* use try/catch and report errors via a set of standard pins: Success (Bang), Error (Bang) and Error Message (String) 

== Observables
If you are dealing with asynchronous datasources - async await, task, events - always hand them to your users as Observables. You might, for example, use Observable.FromEventPattern....

== Resource Providers
Libraries that make use of unmanaged code often require to make use of the Dispose functionality in C#. There are multiple ways to approach this issue. If you are importing a library, your users should not have to worry about disposing objects, you should take care of that in the wrapper...

== Restore Methods
When importing types with generic type parameters, you need to write restore methods for them.

== Default Values
Define default values for imported types in the TypeImporter or via the property “IsDefault” in the Node attribute. This is desirable to avoid NULL values in a patch. If you know what you’re doing, you can still have a type without default value and handle NULL values in a patch correctly.

The node marked as default must not have a side-effect. This may not always be possible/make sense, then we’ll still have to deal with null

== Immutability
Mark types as immutable in the TypeImporter or via the property “IsImmutable” in the Node attribute, if applicable. .NET does not yet have an understanding of immutability, we therefore need to tell VL which things are immutable.

= Nugets
Don't reference your own nuget in any .vl documents that contribute to a nuget other than: demo, test and help patches

[NOTE]
When using a .vlimport file for a managed .dll beware that there can only be one such file per .dll! Thus if you need to import any type from e.g. the mscorelib.dll that needs to be added to the VL.CoreLib project.

== Demo Patches
still to be defined: in what form to provide demo patches

== Tests
still to be defined: in what form to provide tests (patches, code,..) that can be run automated

== Help Patches
still to be defined: in what form to provide help patches