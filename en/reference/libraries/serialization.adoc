= Serialization and Deserialization

[quote]
Serialization is the process of translating data structures into a format (text or series of bytes) that can be stored (for example, in a file) or transmitted (for example, across a network) and reconstructed later. The opposite operation, extracting a data structure from a serialized format, is called deserialization

-- via link:https://en.wikipedia.org/wiki/Serialization[Wikipedia]

== Common Formats

There are three commonly used text formats for serialization, called link:https://en.wikipedia.org/wiki/XML[XML], link:https://en.wikipedia.org/wiki/JSON[JSON] and link:https://en.wikipedia.org/wiki/Comma-separated_values[CSV] and another common binary format called link:https://en.wikipedia.org/wiki/BSON[BSON]. While binary formats are typically smaller, which results in faster read/write times, the advantage of text formats is human readability which helps with debugging. Also, when interacting with the web it is common to choose JSON as this can be easily parsed and created from java-script.

== Usage scenarios
Depending on your scenario there are different ways to go about de/serialization:

=== Controlling both the serialization and deserialization
If you can define the format yourself, you basically have two choices:

==== The slow, persistent way
When you're saving the state of a program to disk, you may want think about different versions of your file-format because the data-structure you're saving may evolve over time but you may still want your application to be able to load files saved with earlier versions.

In this case you'll want to define the format yourself as it is then in your hand to change the format whenever needed, adapt the serialization and deserialization process accordingly and have the option to retain backwards-compatibility by providing different de/serializers for different versions of your format.

The following nodes allow you to build data-structures

- XElement (Join) [XML]
- XAttribute (Join) [XML]

that can then be serialized to a string format using:

- ToJSON [XML]
- ToString [XML]

Building an extra data-structure that is only used for serialization is an overhead but also has the advantage that you can leave things out that you don't need to serialize and define exactly how the resulting format will look like. 

**image: example data-structure and its serialization as XML and JSON strings**

=== The quick, volatile way
When you need to send data from one instance of your application to another over a network and the data is never persisted to disk chances are that you don't care about the actual format.

In this case you can use one of the runtime serializers provided that can serialize most datatypes directly without the need for building an extra data-structure for serialization as in the example above. While this saves time it, comes with the disadvantage that you cannot leave things out that don't need to be serialized and thus may have some overhead in the formats size.

- Serialize (JSON) [Runtime.Serialization] -> Deserialize (JSON) [Runtime.Serialization]
- Serialize (BSON) [Runtime.Serialization] -> Deserialize (BSON) [Runtime.Serialization]
- Serialize (Binary) [Runtime.Serialization] -> Deserialize (Binary) [Runtime.Serialization]
- Serialize (XML) [Runtime.Serialization] -> Deserialize (XML) [Runtime.Serialization]

**image: example MyType automatically serialized and deserialized**

In case you want to learn more about the inner workings of those nodes, check the documentation of the link:https://mbraceproject.github.io/FsPickler/[FSPickler] library on which they are based on. 

== Serializing into a given format
 
build structure using xml nodes then use ToJSON [XML] ToString [XML]

== Deserializing from a given format

ParseJson [XML], Parse [XML] the use xElement (split), xpath..