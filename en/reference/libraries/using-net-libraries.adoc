:experimental:
:figure-caption!:

= Using .NET Libraries

Any static operation or member of a class defined in a .NET .dll (library) can be used as a node in VL.

== Referencing Libraries

=== Local .NET libraries
To get access to the content of a library in a patch you only need to _reference_ it as a dependency in the .vl document. Here are 3 ways to do so:

* Drop a .dll onto the patch 
* Press kbd:[Ctrl + R]
* Via menu:Document[Dependencies > Files > Add Existing...]

.Add existing File as dependency.
image::../../images/vl-Dependencies-File.png[]

=== Libraries from the GAC (Global Assembly Cache)

Instead of a local .dll you can also reference any library from the link:https://docs.microsoft.com/en-us/dotnet/framework/app-domains/gac[GAC] that also holds all the main libraries shipping with .NET:

* Press kbd:[Ctrl + Shift + R]
* via menu:Document[Dependencies > Files > Add .NET Framework Assembly...]

.Use kbd:[Ctrl + F] in this window to find libraries in the GAC.
image::../../images/vl-libraries-using-GACWindow.png[]

== Accessing nodes

Each referenced .dll shows up as a top-level category in the NodeBrowser. Enter it to explore the libraries' namespaces, types and operations. Hover the individual operations to read their associated xml-documentation. Click any operation to use it as a node in the patch.

.NodeBrowser with the namespace 'DemoLib' from the VL.DemoLib.dll showing up as a toplevel category.
image::../../images/vl-libraries-using-NodeBrowser.png[]

Like this you can use practically any thirdparty .NET library and start patching with it immediately. 

== For your Consideration
Having access to just about any .NET library directly in VL is indeed quite convenient and powerful. With many simple libraries you'll have instant success. But obviously most libraries you'll find in the wild are not designed to be used in a dataflow context like VL. Patching with those is still possible but will require a better understanding of things than we'd normally want to ask from our users. Therefore we consider this feature of _"using .NET libraries directly"_ to be for the more advanced audience. 

Below is a list of typical issues you'll encounter with third-party libraries which are often reasons for wrapping them into a more VL friendly form. See link:/reference/libraries/patching-libraries.adoc[Forwarding .NET Libraries] for a few features we built into VL to make it easy to create such wrappers.

=== Incompatible types
Libraries often use their own types for Vectors, Matrices,.. which will not be compatible directly with the corresponding VL types. You'll need to find a way to convert between those. Sometimes it may only be value ranges, like: angles or color components in VL go from 0..1 while other libraries often use different ranges. 

Wrappers can hide those conversions from the user.

=== Mutability
In a dataflow context it is most usable to deal with immutable datatypes. However most types from .NET libraries are mutable.

=== Events
Many .NET libraries expose events that do not conform to the link:https://docs.microsoft.com/en-us/dotnet/csharp/modern-events[.NET Core Event Pattern], which means that they cannot be automatically translated to Observables in VL. For those cases you'll have to write a wrapper in C# that converts the event to an observable manually, see link:https://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.fromevent(v=vs.103).aspx[Observable.FromEvent].

=== Error Handling
There are different ways libraries can deal with errors but typically as users we want to have one consistent way. 

Building a wrapper around a library allows us to adopt the VL way of handling errors and expose that to the end-user. 

=== Too Low-level
Third-party libraries are often rather low-level in the functionality they provide. In a visual language like VL we prefer to use more high-level nodes that already combine some features of a library to reusable building blocks. 

Wrappers can be useful to combine often used low-level functionality into convenient high-level nodes.

