= Writing nodes using C#

Writing your own nodes for VL using C# requires no VL specific knowledge or preparation. Essentially you’re writing plain C# code that VL then turns into nodes. Here is a step by step guide to get you started:

== Start from a Template

In VisualStudio (2015 or 2017) create a new project by choosing the “Visual C# > Class Library (.NET Framework)” template. 

*Image:Screenshot of template chooser*

This will create a .sln, a .csproj and a Class1.cs file which looks like this:

*Image:Screenshot of empty Class1*

The Namespace you specify here will turn into the nodes category in VL. Nested namespaces (using dot syntax) will be translated to nested categories accordingly. 

Now *any pulibc static operation and every member operation of a public class you write will turn into a VL node*. The most simple node you can write is therefore:

```csharp
namespace MyCustomNodes
{
    public static class MyStaticNodes
    { 
        public static float Add(float input, float input2)
        {
            return input + input2;
        }
    }
}
```

This is basically it. Now build the project and you'll get a managed .dll containing your nodes. From here you continue with link:/reference/libraries/importing_nodes.adoc[Importing Nodes] to use those operations as nodes in VL.

*Image:Resulting Node in VL*

== More Details

Here are some simple examples and a few more details that will help you create your own nodes. Those are also available via:
 https://github.com/vvvv/VLDemoLib

=== Pin Names

For better readability in VL, an operation's arguments are separated at camelCasing. So "firstInput" in c# turns into "First Input" in VL. The default “return” value is called "Output" in VL.

```csharp
public static float Foo(float firstInput, float secondInput)
{
    return firstInput + secondInput;
}
```
*Image:Tooltip shows pin name*

=== Default Values

Simply use the c# notation for defaults to define defaults for inputs in VL.

```csharp
public static float Defaults(float firstInput=44f, float secondInput=0.44f)
{
    return firstInput + secondInput;
}
```
*Image:Default on Input*

=== Multiple Outputs

Instead of returning a single value you can also use one or even multiple out parameters that will show up as output pins on the VL node:

```csharp
public static void MultipleOutputs(float firstInput, float secondInput, out float added, out float multiplied)
{
    added = firstInput + secondInput;
    multiplied = firstInput * secondInput;
}
```
*Image:A node with multiple outputs*

=== Function Overloading

You can write multiple operations with the same name that only differ in the number of input parameters:

```csharp
public static float MyAddition(float input, float input2)
{
    return input + input2;
}

public static float MyAddition(float input, float input2, float input3)
{
    return input + input2 + input3;
}
```

Choosing the respective node in the NodeBrowser will then ask you for a further choice to specify the which version you want to use.
*Image:NodeBrowser shows two nodes*

=== Using Enums

You can use custom c# enums as input or output types to operations:
```csharp
//the enum itself needs to be declared outside of the static class
//it doesn't work nested in a class yet!
public enum DemoEnum { Foo, Bar };
    
public static string StaticEnumDemo(DemoEnum e)
{
    return e.ToString();
}
```
*Image:Enum IOBox in VL patch*

For an example of a dynamic enum (ie, one whose entries change during runtime), see below.

=== Using Generics

VL embraces generics, so of course you can write generic nodes easily:

```csharp
public static string Generic<T>(T input)
{
    return input.ToString();
}
```
*Image:Generic pin out of node*

=== Operating on Spreads

The c# IEnumerable<> appears as Sequence<> in VL:

```csharp
public static IEnumerable<float> ReverseSequence(IEnumerable<float> input)
{
    return input.Reverse();
}
```
*Image:Spread node*

=== Documentation

Use XML documentation in C# to provide some information about your nodes:

- Summary: A one-liner info about the node
- Remarks: Some additional remarks, like usage instructions, warnings,.. can be multi-line
- Tags: A list of space-separated tags to find the node in the NodeBrowser (only include terms that are not already part of the nodes name and category
- Param name: Short info for each Input
- Returns: Short info about the result of the node
      
```csharp
///<summary>Multiplies input by two</summary>
///<remarks>Some additional remarks</remarks>
///<tags>space separated tags</tags>
///<param name="a">The A Parameter</param>
///<returns>Returns 2 a</returns>
public static int HTMLDocuTest(int a)
{
    return a*2;
}
```
*Image:Documentation shows up in NodeBrowser and Tooltip*

NOTE: Don't forget to enable "XML Documentation File" in the c# projects properties to make sure the .xml file holding the documentation is generated. This file will then always need to be next to the .dll, therfore always move those two files together!

=== C# Ref Paramters

You can use C# _ref_ parameters, but beware: Assigning the parameter leads to undefined behavior in VL (for now), so only make use of it in a readonly fashion!

```csharp
public static int RefParams(ref int firstInput)
{
    return firstInput + 4444;
}
```

=== Datatypes

In VL you can also use any datatype you define as a class or struct in c#. 

- Any constructor will be available as a Create node
- Any get-property will show up as a node returning the properties value
- Any set-property will show up as a node called Set.. allowing you to set the properties value
- Any public member operation will be available as a node in VL. Private or Protected operations will be ignored.

```csharp
public class MyDataType
{
    float FX;
    
    public float X
    {
        get { return FX; }
        set
        {
            if (value < 100)
                    FX = value;
            }
        }
    }

    public MyDataType(float x)
    {
        FX = x;
    }

    public float Update(float factor=1f)
    {
        FX *= factor;
        return FX;
    }
    
    public float AnotherNode(float factor=1f)
    {
        FX /= factor;
        return FX;
    }
}
```
*Image:Corresponding nodes*

=== Observables

If you are dealing with asynchronous datasources - async await, task, events, delegates - always expose them to VL as Observables. 

==== From Events

Here is how you can convert a c# event to an Observable using a helper function called `Observable.FromEvent()` that comes with the VL.Core nuget:

Let's assume you have a datatype `Camera` that has an event like:

```csharp
public event EventHandler EventFrame;`
```

and you want to receive notifications of that event via the output of a node in VL. 

First you need to create a class for the type of notification you want to receive in VL which will typically look like this:

```csharp
public class MyNotification<T, U>
{
    public readonly T Sender;
    public readonly U EventArgs;

    public MyNotification(T sender, U eventArgs)
    {
        Sender = sender;
        EventArgs = eventArgs;
    }
}
```

Next you can create e.g. a static operation node that receives an instance of the `Camera` in VL and returns an `Observable<MyNotification>` on its output:

```csharp
public static IObservable<MyNotification<Camera, EventArgs>> OnEvent(this Camera cam)
{
    return ObservableNodes.FromEvent<EventHandler, MyNotification<Camera, EventArgs>>(
        cam,
        addHandler: handler => cam.EventFrame += handler,
        removeHandler: handler => cam.EventFrame -= handler,
        conversion: notificationProcessor => (_, e) =>
        {
            var cn = new MyNotification<Camera, EventArgs>(cam, e);
            notificationProcessor(cn);
        });
}
```
*Image:How this looks in VL*

==== From Delegates

Here is how you can convert a c# delegate to an Observable using a helper function called `Observable.FromEvent()` that comes with the VL.Core nuget:

Let's assume you have a datatype `Body` that has a delegate like:

```csharp
public delegate bool OnCollisionEventHandler (Fixture fixtureA, Fixture fixtureB, Collision collision);
```

and you want to receive a notifications of when that delegate is called via the output of a node in VL. 

First you need to create a class for the type of notification you want to receive in VL which in this case may look like this:

```csharp
public class CollisionEvent
{
    public readonly Contact Contact;
    public readonly Fixture FixtureA;
    public readonly Fixture FixtureB;

    public CollisionEvent(Fixture fixtureA, Fixture fixtureB, Contact contact)
    {
        FixtureA = fixtureA;
        FixtureB = fixtureB;
        Contact = contact;
    }

    public bool CancelCollision { get; set; }
}
```

Next you can create e.g. a static operation node that receives an instance of the `Body` in VL and returns an `Observable<CollisionEvent>` on its output:

```csharp
public static IObservable<CollisionEvent> OnCollision(this Body body)
{
    return ObservableNodes.FromEvent<OnCollisionEventHandler, CollisionEvent>(
        body,
        addHandler: handler => body.OnCollision += handler,
        removeHandler: handler => body.OnCollision -= handler)
        conversion: handler => (fixtureA, fixtureB, contact) =>
        {
            var e = new CollisionEvent(fixtureA, fixtureB, contact);
            handler(e);
            return !e.CancelCollision;
        });
}
```
*Image:How this looks in VL*

=== Dynamic Enums

Dynamic enums are useful in cases where you want to offer a user a list of items to choose from, where the entries of that list may change during runtime. A typical example are nodes that give access to hardware devices that can be plugged in and removed anytime. 

Consider a normal enum in c#:
```csharp
enum MyEnum = { Foo, Bar }
```
Here `MyEnum` is what we call the type and `{ Foo, Bar }` makes its definition.

And the way we want to use such an enum in our code is to have it as the type of an input parameter to one of our operations,  like this:
```csharp
public static string EnumDemo(MyEnum e)
{
    return e.ToString();
}
```

Now in order to create a dynamic enum for VL we also need those two elements, the type and the definition. Both need to be implemented as classes in c#:

- The type needs to implement `IDynamicEnum` 
- The definition needs to implment `IDynamicEnumDefinition`

both of which come with the VL.Core nuget. 

NOTE: For now the VL.Core nuget is only available as pre-release via http://vvvv.org:8111/guestAuth/app/nuget/v1/FeedService.svc/

To make their use easier there are also two baseclass implementations available:

- `DynamicEnumBase<T, U>`
- `DynamicEnumDefinitionBase<U>`

Note that the DynamicEnumDefinitionBase is a Singleton, meaning that its implementation takes care that always only one instance exists of it globally. We want this because it is important that any node that is referring to a specific enum definition always gets exactly the same entries!

Using the above two baseclasses, an implmentation of your own dynamic enum could look like this:

First derive from the `DynamicEnumBase` to create your own enum type. 

```csharp
[Serializable]
public class MyEnum: DynamicEnumBase<MyEnum, MyEnumDefinition>
{
    public MyEnum(string value) : base(value)
    {
    }

    public static MyEnum Default
    {
        get
        {
            if (MyEnumDefinition.Instance.Entries.Count > 0)
            {
                return new MyEnum(MyEnumDefinition.Instance.Entries[0]);
            }
            else
            {
                return new MyEnum("No Entries");
            }
        }
    }
}
```

The code above most likely doesn't need many changes for your own implementation except:

- Give it a proper name instead of "MyEnum", something like e.g. "MidiInputDevice". Note the singular in the naming: This type represents one entry in the enumeration. 
- Note the second type parameter `MyEnumDefinition` which connects your enum to its definition and should similarly be called "MidiInputDeviceDefinition"

Next derive from `DynamicEnumDefinitionBase` to implement the class that provides the available entries of your enum to the system. Here you only have to override two functions: One that can return a list of current enum-entries as strings and another one that tells the system when your enum-entries have changed. 

```csharp
public class MyEnumDefinition : DynamicEnumDefinitionBase<MyEnumDefinition>
{
    //return the current enum entries
    protected override IReadOnlyList<string> GetEntries()
    {
    }

    //inform the system that the enum has changed
    protected override IObservable<object> GetEntriesChangedObservable()
    {
    }
}
```

Implementations here will vary depending on your usecase. A simple example could look like this:

```csharp
public class MyEnumDefinition : DynamicEnumDefinitionBase<MyEnumDefinition>
{
    ObservableCollection<string> FMyEntries = new ObservableCollection<string>();

    //return the current enum entries
    protected override IReadOnlyList<string> GetEntries()
    {
        return FMyEntries;
    }

    //inform the system that the enum has changed
    protected override IObservable<object> GetEntriesChangedObservable()
    {
        return Observable.FromEventPattern<NotifyCollectionChangedEventHandler, NotifyCollectionChangedEventArgs>(
                h => FMyEntries.CollectionChanged += h,
                h => FMyEntries.CollectionChanged -= h);
    }

    public void AddEntry(string entry)
    {
        FMyEntries.Add(entry);
    }

    public void RemoveEntry(string entry)
    {
        FMyEntries.Remove(entry);
    }
}
```

NOTE: For the `Observable` type in this example implementation you need to install the 'RX-Main' nuget. 

Lastly there is one thing you'll have to do in VL to get your dynamic enum working: So far when you create a node in VL that has an input typed with your ''MyEnum'', the inputs tooltip will show "null". This is because the VL type system does not know how to deal with the type yet. What we want is that the type-system automatically creates an instance of ''MyEnum'' whenever it encounters it. 

For this to happen we have to specify a default constructor for ''MyEnum'' and this can only be done using a Typeforward in VL!

In the .vl document where you have set a reference to the .dll that holds your enum open the Solution Explorer (Ctrl+J), choose 'Imports' in the dropdown and use the treeview to navigate to your 'MyEnum' class. Unfolding it you should see the 'Default' operation which you can take and drag-drop onto the document canvas. Renaming this operation to 'CreateDefault' will hint to the type-system to use this operation to initialize the type, whenever it encounters the type 'MyEnum'. 

For now this also needs a restart but then you should see a valid instance in the pin that uses 'MyEnum' and you can now create an IOBox to control it. 

*Image:How this looks in VL*











